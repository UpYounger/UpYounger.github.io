{"meta":{"title":"别打我很疼ღ","subtitle":null,"description":null,"author":"别打我很疼ღ","url":"https://upyounger.github.io","root":"/"},"pages":[{"title":"关于","date":"2019-05-14T00:48:48.000Z","updated":"2019-05-14T00:52:09.806Z","comments":true,"path":"about/index.html","permalink":"https://upyounger.github.io/about/index.html","excerpt":"","text":"欢迎浏览别打我很疼ღ的博客！"},{"title":"分类","date":"2019-05-14T00:36:39.000Z","updated":"2019-05-14T00:37:17.363Z","comments":true,"path":"categories/index.html","permalink":"https://upyounger.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-05-14T00:35:45.000Z","updated":"2019-05-14T00:37:33.839Z","comments":true,"path":"tags/index.html","permalink":"https://upyounger.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"线程池的创建方法","slug":"线程池的创建方法","date":"2019-09-19T09:07:18.000Z","updated":"2019-09-19T09:17:48.421Z","comments":true,"path":"2019/09/19/线程池的创建方法/","link":"","permalink":"https://upyounger.github.io/2019/09/19/线程池的创建方法/","excerpt":"","text":"java 创建线程池12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/* * java 创建线程池 四种 * */import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.TimeUnit;public class ThreadPoolDemo &#123; public static void main(String[] args) &#123; // 创建一个单线程的线程池 串行 顺序执行完成// ExecutorService executors =Executors.newSingleThreadExecutor();// 创建一个固定大小的线程池 多个线程同时运行 ExecutorService executors = Executors.newFixedThreadPool(2); /* 创建一个可缓存的线程池，如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲的线程 * 当任务数量增加时，此线程池又可以智能的添加新线程来处理任务，此线程池不会对线程池的大小做限制， * 线程池的大小完全依赖于操作系统（或者说JVM）能够创建的最大线程的大小 * */// ExecutorService executors = Executors.newCachedThreadPool(); // 创建一个大小无限制的线程池，此线程池支持定时及周期性执行任务的需求// ScheduledExecutorService executors = Executors.newScheduledThreadPool(3); executors.execute(new MyRunnable()); executors.execute(new MyRunnable()); // 方法4// executors.schedule(new MyRunnable(),1000, TimeUnit.MILLISECONDS);// executors.schedule(new MyRunnable(),3000, TimeUnit.MILLISECONDS); executors.shutdown(); &#125;&#125;class MyRunnable implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt;10 ; i++) &#123; System.out.println(Thread.currentThread().getName()+\" : Run Count Number--\"+i); try &#123; Thread.sleep(300); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://upyounger.github.io/categories/Java/"}],"tags":[{"name":"-java","slug":"java","permalink":"https://upyounger.github.io/tags/java/"}]},{"title":"Java容器知识点整理","slug":"Java容器知识点整理","date":"2019-08-02T03:46:11.000Z","updated":"2019-08-02T04:49:42.072Z","comments":true,"path":"2019/08/02/Java容器知识点整理/","link":"","permalink":"https://upyounger.github.io/2019/08/02/Java容器知识点整理/","excerpt":"","text":"java 容器都有哪些？List 、ArrayList、Vectory、map、HashTable、HashMap、Hashset数组、String、java.util包下的集合容器 （如图：）(Queue: 先进先出的线性表)Collection 和 Collections 有什么区别？java.util.Collection 是一个集合接口。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式。java.util.Collections 是一个包装类。它包含有各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，服务于Java的Collection框架。List、Set、Map 之间的区别是什么？List和Set都是conllection的子接口或者实现类​ List 有序可重复，允许存入多个null；​ Set 无序不可重复，只允许一个null；Map不是conllection的子接口或者实现类，Map是一个借口HashMap 和 Hashtable 有什么区别？HashMap和HashTable都实现了Map接口，主要区别从三个方面入手：线程安全性、同步（synchronization）、速度。HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。由于Hashtable是线程安全的也是synchronized，所以在单线程环境下它比HashMap要慢。如果你不需要同步，只需要单一线程，那么使用HashMap性能要好过Hashtable。HashMap不能保证随着时间的推移Map中的元素次序是不变的。要注意的一些重要术语：1) sychronized意味着在一次仅有一个线程能够更改Hashtable。就是说任何线程要更新Hashtable时要首先获得同步锁，其它线程要等到同步锁被释放之后才能再次获得同步锁更新Hashtable。2) Fail-safe和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。3) 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。我们能否让HashMap同步？HashMap可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap);结论：Hashtable和HashMap有几个主要的不同：线程安全以及速度。仅在你需要完全的线程安全的时候使用Hashtable，而如果你使用Java 5或以上的话，请使用ConcurrentHashMap吧。如何决定使用 HashMap 还是 TreeMap？说一下 HashMap 的实现原理？说一下 HashSet 的实现原理？ArrayList 和 LinkedList 的区别是什么？如何实现数组和 List 之间的转换？ArrayList 和 Vector 的区别是什么？Array 和 ArrayList 有何区别？在 Queue 中 poll()和 remove()有什么区别？哪些集合类是线程安全的？迭代器 Iterator 是什么？Iterator 怎么使用？有什么特点？Iterator 和 ListIterator 有什么区别？怎么确保一个集合不能被修改？","categories":[{"name":"Java","slug":"Java","permalink":"https://upyounger.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://upyounger.github.io/tags/java/"}]},{"title":"Java基础题目整理","slug":"Java基础题目整理","date":"2019-08-02T03:13:54.000Z","updated":"2019-08-02T04:45:56.422Z","comments":true,"path":"2019/08/02/Java基础题目整理/","link":"","permalink":"https://upyounger.github.io/2019/08/02/Java基础题目整理/","excerpt":"","text":"面试题型大纲面试题模块儿包含了十九个模块，分别为：java基础、容器、多线程、反射、对象拷贝、java Web模块、异常、网络、设计模式、spring/springMVC、spring Boot/spring Cloud、Hibernate、Mybatis、RabbitMQ、kafka、Zookeeper、Mysql、Redis、JVM​Java基础题目整理Jdk与jre有什么区别？JRE是java运行时的环境，包含了java虚拟机、java基础类库，是使用java语言编写的程序运行时所需要的软件环境，是提供给想要运行java程序的用户使用的。JDK是java开发工具包，是程序员使用java开发java程序所需要的开发工具包，是提供给程序员使用的。JDK包含了JRE，同时还包含了编译java源码的javac，还包含了很多Java程序调试和分析的工具：jconsole、jvisualvm等工具软件，还包含了编写java程序所需的文档和案例程序。= = 和eauals的区别是什么？对于基本数据类型来说：== 比较的是两者的值是否相等对于引用数据类型来说（对象）：（1）“==”比较的是引用的地址是否相同（即是否是同一辆汽车（注意，只有一辆汽车））；Object中的.equals()方法和”==’功能一样（2）但是String类中的.equals()方法重写了，比较的是两个引用对象的内容是否相同（即是否是完全相同的汽车（注意，有两辆汽车，且一模一样，完全相同））。==用于比较数据是否相等，如果用它在比较对象的话，它只能比较对象在栈的内容是否相同。而eqals函数用来比较对象的内容是否相等（堆里的内容）。（栈用来保存对象的引用，对象的的内容放在堆里面，由栈的引用指向他，java里的数组也是如此。）两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？不对！两个对象equals相等，则他们的hashCode()必须相等，反之不一定。​ 详解：​ hashCode是继承自Object的方法，首先看hashCode方法的定义：1public native int hashCode();​ 可见hashCode方法是一个native方法【”A native method is a Java method whose implementation is provided by non-java code.”】，因为native方法是由非Java语言实现的，所以这个方法的定义中也没有具体的实现。根据jdk文档，该方法的实现一般是“通过将该对象的内部地址转换成一个整数来实现的”，这个返回值就作为该对象的哈希码值返回。​ 由此可知默认情况下：​ 两个对象==相等，则其hashcode一定相等，反之不一定成立。​ 两个对象equals相等，则其hashcode一定相等，反之不一定成立。【和上一条等价，因为Object的equals实现用的就是 对象的==相等来判断】​ 如果equals方法和hashCode方法被重写，则需满足hashCode 的常规协定：​ 1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。​ 2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。​ 3.如果根据 equals(java.lang.Object)) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不要求一定生成不同的整数结果。但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。​ 所以按规定重写的情况下：​ 两个对象equals相等，则它们的hashcode必须相等，反之则不一定。​ 两个对象==相等，则它们的hashcode必须相等，反之则不一定。【==相等，则equals必然相等】​ 所以总的来说，只要按照规定，则有：​ 两个对象equals相等，则它们的hashcode必须相等，反之则不一定。Hash散列值有冲突的情况，虽然概率很低。https://www.cnblogs.com/jesonjason/p/5492208.htmlfinal 在 java 中有什么作用？final 修饰一个类时，这个类将不会被继承，同时该类的所有成员方法都会被隐式的指定为fianal方法final修饰一个方法时，表示这个方法不会被重写（可以被重载成多个final方法）此处需要注意的一点是：因为重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义相同的方法名和参数，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）final修饰成员变量时，标识这个变量只能被赋值一次，且不会被修改，如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。java 中的 Math.round(-1.5) 等于多少？-1扩展JDK中的java.lang.Math类round:返回四舍五入，负.5小数返回较大整数，如-1.5返回-1。ceil:返回小数所在两整数间的较大值，如-1.5返回-1。tail:返回小数所在两整数间的较小值，如-1.5返回-2。详解String 属于基础的数据类型吗？不属于！ String 是final修饰的java类，java的基本类型有8种：​ 1：字符型： byte char​ 2：基本类型：short，int,long​ 3: 浮点类型：float,double​ 4: 布尔类型： booleanjava 中操作字符串都有哪些类？它们之间有什么区别？String、StringBuffer、StringBuilder区别：String是不可变的对象，对每次对String类型的改变时都会生成一个新的对象，StringBuffer和StringBuilder是可以改变对象的。对于操作效率：StringBuilder &gt; StringBuffer &gt; String对于线程安全：StringBuffer 是线程安全，可用于多线程；StringBuilder 是非线程安全，用于单线程不频繁的字符串操作使用 String。反之，StringBuffer 和 StringBuilder 都优于StringString str=”i”与 String str=new String(“i”)一样吗？不一样！他们不是同一个对象。前者是一个常量，后者重新new了一个对象，内存空间不一样。如何将字符串反转？https://www.cnblogs.com/lanseyitai1224/p/6955609.html 七八种方法 见附录String 类的常用方法都有那些？eauals(),length(),concat(),charAt(),substring(),contains(),hashCode(),indexOf(),isEmpt() ……抽象类必须要有抽象方法吗？抽象类不一定有抽象方法，但是有抽象方法的类一定是抽象类普通类和抽象类有哪些区别？1.抽象类不能被实例化。2.抽象类可以有构造函数，被继承时子类必须继承父类的一个构造方法，抽象方法不能被声明成静态方法。抽象类的构造函数用来初始化抽象类的一些字段，而这一切都在抽象类的派生类实例化之前发生。不仅如此，抽线类的构造函数还有一种巧妙应用：就是在其内部实现子类必须执行的代码。3.抽象方法允许声明，而无需实现，抽象类可以允许普通方法有主体。4.有抽象方法的类一定为抽象类，抽象类不一定只含有抽象方法。5.抽象类的子类必须实现抽象类中的所有抽象方法，否则这个类也是抽象类。抽象类能使用 final 修饰吗？不可以，final关键字不可以用来修饰抽象类和接口接口和抽象类有什么区别？1.接口和抽象类都不能被实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。2.抽象类要被子类继承extends，接口要被类实现3.接口只能做方法申明，抽象类可以做方法申明，也可以做方法实现4.接口里定义的变量只能是公共的静态常量，抽象类定义的变量是普通变量 ..5.抽象类里面的抽象方法必须被子类全部实现，如果子类不能实现父类全部抽象方法，则这个子类也是抽象类；一个类实现接口的时候，如果不能全部实现接口方法，则这个类也是抽象类6.抽象方法只能声明，不能实现。抽象类是重构的结果，接口是设计的结果。7.抽象类里面可以没有抽象方法8.如果一个类里面有抽象方法，那么这个类是抽象类9.抽象方法要被实现，所以不能是私有的，也不能是静态的10.接口可以继承接口，并且可以多继承，而抽象类只能单根继承java 中 IO 流分为几种？https://www.cnblogs.com/QQ846300233/p/6046388.htmlBIO、NIO、AIO 有什么区别？https://blog.csdn.net/u010310183/article/details/81700405Files的常用方法都有哪些？https://www.cnblogs.com/cocoxu1992/p/10460994.html附录两个对象的 hashCode() 相同，则 equals() 也一定为 true，对吗？equals()：反映的是对象或变量具体的值，即两个对象里面包含的值–可能是对象的引用，也可能是值类型的值。hashCode()：计算出对象实例的哈希码，并返回哈希码，又称为散列函数。根类Object的hashCode()方法的计算依赖于对象实例的D（内存地址），故每个Object对象的hashCode都是唯一的；当然，当对象所对应的类重写了hashCode()方法时，结果就截然不同了。之所以有hashCode方法，是因为在批量的对象比较中，hashCode要比equals来得快，很多集合都用到了hashCode，比如HashTable。两个obj，如果equals()相等，hashCode()一定相等。两个obj，如果hashCode()相等，equals()不一定相等（Hash散列值有冲突的情况，虽然概率很低）。所以：可以考虑在集合中，判断两个对象是否相等的规则是：第一步，如果hashCode()相等，则查看第二步，否则不相等;第二步，查看equals()是否相等，如果相等，则两obj相等，否则还是不相等。1、首先equals()和hashcode()这两个方法都是从object类中继承过来的。equals()是对两个对象的地址值进行的比较（即比较引用是否相同）。hashCode()是一个本地方法，它的实现是根据本地机器相关的。2、Java语言对equals()的要求如下，这些要求是必须遵循的：A 对称性：如果x.equals(y)返回是“true”，那么y.equals(x)也应该返回是“true”。B 反射性：x.equals(x)必须返回是“true”。C 类推性：如果x.equals(y)返回是“true”，而且y.equals(z)返回是“true”，那么z.equals(x)也应该返回是“true”。D 一致性：如果x.equals(y)返回是“true”，只要x和y内容一直不变，不管你重复x.equals(y)多少次，返回都是“true”。任何情况下，x.equals(null)，永远返回是“false”；x.equals(和x不同类型的对象)永远返回是“false”。3、equals()相等的两个对象，hashcode()一定相等；反过来：hashcode()不等，一定能推出equals()也不等；hashcode()相等，equals()可能相等，也可能不等。为什么选择hashcode方法？———————————————-以java.lang.Object来理解,JVM每new一个Object,它都会将这个Object丢到一个Hash哈希表中去,这样的话,下次做Object的比较或者取这个对象的时候,它会根据对象的hashcode再从Hash表中取这个对象。这样做的目的是提高取对象的效率。具体过程是这样:\\1. new Object(),JVM根据这个对象的Hashcode值,放入到对应的Hash表对应的Key上,如果不同的对象确产生了相同的hash值,也就是发生了Hash key相同导致冲突的情况,那么就在这个Hash key的地方产生一个链表,将所有产生相同hashcode的对象放到这个单链表上去,串在一起。\\2. 比较两个对象的时候,首先根据他们的hashcode去hash表中找他的对象,当两个对象的hashcode相同,那么就是说他们这两个对象放在Hash表中的同一个key上,那么他们一定在这个key上的链表上。那么此时就只能根据Object的equal方法来比较这个对象是否equal。当两个对象的hashcode不同的话，肯定他们不能equal.可能经过上面理论的讲一下大家都迷糊了，我也看了之后也是似懂非懂的。下面我举个例子详细说明下。list是可以重复的，set是不可以重复的。那么set存储数据的时候是怎样判断存进的数据是否已经存在。使用equals()方法呢，还是hashcode()方法。假如用equals()，那么存储一个元素就要跟已存在的所有元素比较一遍，比如已存入100个元素，那么存101个元素的时候，就要调用equals方法100次。但如果用hashcode()方法的话，他就利用了hash算法来存储数据的。这样的话每存一个数据就调用一次hashcode()方法，得到一个hashcode值及存入的位置。如果该位置不存在数据那么就直接存入，否则调用一次equals()方法，不相同则存，相同不存。这样下来整个存储下来不需要调用几次equals方法，虽然多了几次hashcode方法，但相对于前面来讲效率高了不少。为什么要重写equals方法？——————————————-因为Object的equal方法默认是两个对象的引用的比较，意思就是指向同一内存,地址则相等，否则不相等；如果你现在需要利用对象里面的值来判断是否相等，则重载equal方法。说道这个地方我相信很多人会有疑问，相信大家都被String对象的equals()方法和”==”纠结过一段时间，当时我们知道String对象中equals方法是判断值的，而==是地址判断。那照这么说equals怎么会是地址的比较呢？那是因为实际上JDK中，String、Math等封装类都对Object中的equals()方法进行了重写。我们先看看Object中equals方法的源码：我们都知道所有的对象都拥有标识(内存地址)和状态(数据)，同时“==”比较两个对象的的内存地址，所以说使用Object的equals()方法是比较两个对象的内存地址是否相等，即若object1.equals(object2)为true，则表示equals1和equals2实际上是引用同一个对象。虽然有时候Object的equals()方法可以满足我们一些基本的要求，但是我们必须要清楚我们很大部分时间都是进行两个对象的比较，这个时候Object的equals()方法就不可以了，所以才会有String这些类对equals方法的改写，依次类推Double、Integer、Math。。。。等等这些类都是重写了equals()方法的，从而进行的是内容的比较。希望大家不要搞混了。改写equals时总是要改写hashcode——————————————-java.lnag.Object中对hashCode的约定：在一个应用程序执行期间，如果一个对象的equals方法做比较所用到的信息没有被修改的话，则对该对象调用hashCode方法多次，它必须始终如一地返回同一个整数。如果两个对象根据equals(Object o)方法是相等的，则调用这两个对象中任一对象的hashCode方法必须产生相同的整数结果。如果两个对象根据equals(Object o)方法是不相等的，则调用这两个对象中任一个对象的hashCode方法，不要求产生不同的整数结果。但如果能不同，则可能提高散列表的性能。根据上一个问题，实际上我们已经能很简单的解释这一点了，比如改写String中的equals为基于内容上的比较而不是内存地址的话，那么虽然equals相等，但并不代表内存地址相等，由hashcode方法的定义可知内存地址不同，没改写的hashcode值也可能不同。所以违背了第二条约定。又如new一个对象，再new一个内容相等的对象，调用equals方法返回的true，但他们的hashcode值不同，将两个对象存入HashSet中，会使得其中包含两个相等的对象，因为是先检索hashcode值，不等的情况下才会去比较equals方法的。hashCode方法使用介绍————————————————Hash表数据结构常识：一、哈希表基于数组。二、缺点：基于数组的，数组创建后难以扩展。某些哈希表被基本填满时，性能下降得非常严重。三、没有一种简便得方法可以以任何一种顺序遍历表中数据项。四、如果不需要有序遍历数据，并且可以提前预测数据量的大小，那么哈希表在速度和易用性方面是无与伦比的。一、为什么HashCode对于对象是如此的重要：一个对象的HashCode就是一个简单的Hash算法的实现，虽然它和那些真正的复杂的Hash算法相比还不能叫真正的算法，它如何实现它，不仅仅是程序员的编程水平问题，而是关系到你的对象在存取是性能的非常重要的关系.有可能，不同的HashCode可能会使你的对象存取产生，成百上千倍的性能差别.先来看一下，在JAVA中两个重要的数据结构:HashMap和Hashtable，虽然它们有很大的区别，如继承关系不同，对value的约束条件(是否允许null)不同，以及线程安全性等有着特定的区别，但从实现原理上来说，它们是一致的.所以，我们只以Hashtable来说明：在java中，存取数据的性能，一般来说当然是首推数组，但是在数据量稍大的容器选择中，Hashtable将有比数组性能更高的查询速度.具体原因看下面的内容.Hashtable在存储数据时，一般先将该对象的HashCode和0x7FFFFFFF做与操作，因为一个对象的HashCode可以为负数，这样操作后可以保证它为一个正整数.然后以Hashtable的长度取模，得到该对象在Hashtable中的索引.index = (o.hashCode() &amp; 0x7FFFFFFF)%hs.length;这个对象就会直接放在Hashtable的每index位置，对于写入，这和数组一样，把一个对象放在其中的第index位置，但如果是查询，经过同样的算法，Hashtable可以直接从第index取得这个对象，而数组却要做循环比较.所以对于数据量稍大时，Hashtable的查询比数组具有更高的性能.既然一个对象可以根据HashCode直接定位它在Hashtable中的位置，那么为什么Hashtable还要用key来做映射呢?这就是关系Hashtable性能问题的最重要的问题：Hash冲突.常见的Hash冲突是不同对象最终产生了相同的索引，而一种非常甚至绝对少见的Hash冲突是，如果一组对象的个数大过了int范围，而HashCode的长度只能在int范围中，所以肯定要有同一组的元素有相同的HashCode，这样无论如何他们都会有相同的索引.当然这种极端的情况是极少见的，可以暂不考虑，但是对于同的HashCode经过取模，则会产中相同的索引，或者不同的对象却具有相同的HashCode，当然具有相同的索引.所以对于索引相同的对象，在该index位置存放了多个值，这些值要想能正确区分，就要依靠key来识别.事实上一个设计各好的HashTable，一般来说会比较平均地分布每个元素，因为Hashtable的长度总是比实际元素的个数按一定比例进行自增(装填因子一般为0.75)左右，这样大多数的索引位置只有一个对象，而很少的位置会有几个元素.所以Hashtable中的每个位置存放的是一个链表，对于只有一个对象是位置，链表只有一个首节点(Entry)，Entry的next为null.然后有hashCode，key，value属性保存了该位置的对象的HashCode，key和value(对象本身)，如果有相同索引的对象进来则会进入链表的下一个节点.如果同一个索引中有多个对象，根据HashCode和key可以在该链表中找到一个和查询的key相匹配的对象.从上面我看可以看到，对于HashMap和Hashtable的存取性能有重大影响的首先是应该使该数据结构中的元素尽量大可能具有不同的HashCode，虽然这并不能保证不同的HashCode产生不同的index，但相同的HashCode一定产生相同的index，从而影响产生Hash冲突.对于一个象，如果具有很多属性，把所有属性都参与散列，显然是一种笨拙的设计.因为对象的HashCode()方法几乎无所不在地被自动调用，如equals比较，如果太多的对象参与了散列.那么需要的操作常数时间将会增加很大.所以，挑选哪些属性参与散列绝对是一个编程水平的问题.从实现来说，一般的HashCode方法会这样:return Attribute1.HashCode() Attribute1.HashCode()..[ super.HashCode()]，我们知道，每次调用这个方法，都要重新对方法内的参与散列的对象重新计算一次它们的HashCode的运算，如果一个对象的属性没有改变，仍然要每次都进行计算，所以如果设置一个标记来缓存当前的散列码，只要当参与散列的对象改变时才重新计算，否则调用缓存的hashCode，这可以从很大程度上提高性能.默认的实现是将对象内部地址转化为整数作为HashCode，这当然能保证每个对象具有不同的HasCode，因为不同的对象内部地址肯定不同(废话)，但java语言并不能让程序员获取对象内部地址，所以，让每个对象产生不同的HashCode有着很多可研究的技术.如果从多个属性中采样出能具有平均分布的hashCode的属性，这是一个性能和多样性相矛盾的地方，如果所有属性都参与散列，当然hashCode的多样性将大大提高，但牺牲了性能，而如果只能少量的属性采样散列，极端情况会产生大量的散列冲突，如对”人”的属性中，如果用性别而不是姓名或出生日期，那将只有两个或几个可选的hashcode值，将产生一半以上的散列冲突.所以如果可能的条件下，专门产生一个序列用来生成HashCode将是一个好的选择(当然产生序列的性能要比所有属性参与散列的性能高的情况下才行，否则还不如直接用所有属性散列).如何对HashCode的性能和多样性求得一个平衡，可以参考相关算法设计的书，其实并不一定要求非常的优秀，只要能尽最大可能减少散列值的聚集.重要的是我们应该记得HashCode对于我们的程序性能有着重要的影响，在程序设计时应该时时加以注意.请记住：如果你想有效的使用HashMap，你就必须重写在其的HashCode()。还有两条重写HashCode()的原则：不必对每个不同的对象都产生一个唯一的hashcode，只要你的HashCode方法使get()能够得到put()放进去的内容就可以了。即“不为一原则”。生成hashcode的算法尽量使hashcode的值分散一些， 不要很多hashcode都集中在一个范围内，这样有利于提高HashMap的性能。即“分散原则”。掌握了这两条原则，你就能够用好HashMap编写自己的程序了。不知道大家注意没有， java.lang.Object中提供的三个方法：clone()，equals()和hashCode()虽然很典型，但在很多情况下都不能够适用，它们只是简单的由对象的地址得出结果。这就需要我们在自己的程序中重写它们，其实java类库中也重写了千千万万个这样的方法。利用面向对象的多态性——覆盖，Java的设计者很优雅的构建了Java的结构，也更加体现了Java是一门纯OOP语言的特性。Java提供的Collection和Map的功能是十分强大的，它们能够使你的程序实现方式更为灵活，执行效率更高。如何将字符串反转？Java中经常会用到将字符串进行反转的时候，程序员孔乙己总结了7种反转方法，如下：//方法1 递归方法123456789public static String reverse1(String s) &#123; int length = s.length(); if (length &lt;= 1)&#123; return s; &#125; String left = s.substring(0, length / 2); String right = s.substring(length / 2, length); return reverse1(right) + reverse1(left);&#125;//方法2 通过 charAt(int index)返回char值进行字符串拼接1234567public static String reverse2(String s) &#123; int length = s.length(); String reverse = &quot;&quot;; for (int i = 0; i &lt; length; i++) reverse = s.charAt(i) + reverse; return reverse;&#125;//方法3 把字符串转换成字符数组倒叙拼接然后返回值1234567public static String reverse3(String s) &#123; char[] array = s.toCharArray(); String reverse = &quot;&quot;; for (int i = array.length - 1; i &gt;= 0; i--) reverse += array[i]; return reverse;&#125;//方法4 调用StringBuffer中的reverse方法123public static String reverse4(String s) &#123; return new StringBuffer(s).reverse().toString(); &#125;//方法5 把字符串转换成字符数组首位对调位置1234567891011public static String reverse5(String orig) &#123; char[] s = orig.toCharArray(); int n = s.length - 1; int halfLength = n / 2; for (int i = 0; i &lt;= halfLength; i++) &#123; char temp = s[i]; s[i] = s[n - i]; s[n - i] = temp; &#125; return new String(s);&#125;//方法612345678910111213public static String reverse6(String s) &#123; char[] str = s.toCharArray(); int begin = 0; int end = s.length() - 1; while (begin &lt; end) &#123; str[begin] = (char) (str[begin] ^ str[end]); str[end] = (char) (str[begin] ^ str[end]); str[begin] = (char) (str[end] ^ str[begin]); begin++; end--; &#125; return new String(str);&#125;[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);//方法71234567891011121314import java.util.Stack;public class StringReverse &#123; public static String reverse7(String s) &#123; char[] str = s.toCharArray(); Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;(); for (int i = 0; i &lt; str.length; i++) stack.push(str[i]); String reversed = &quot;&quot;; for (int i = 0; i &lt; str.length; i++) reversed += stack.pop(); return reversed; &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://upyounger.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://upyounger.github.io/tags/java/"}]},{"title":"HTTP学习笔记","slug":"HTTP学习笔记","date":"2019-08-02T02:32:58.000Z","updated":"2019-08-02T08:11:36.300Z","comments":true,"path":"2019/08/02/HTTP学习笔记/","link":"","permalink":"https://upyounger.github.io/2019/08/02/HTTP学习笔记/","excerpt":"","text":"HTTP协议概念理解网络分层分为四层：应用层（HTTP、ICMP、FILE）、传输层(TCP、UDP)、网络层(IP)、链路层(网络硬件、操作系统)Ip 网络层添加mac地址（不可变 网卡地址）每经过一层添加相应首部数据（上图对应四个分层）上部四步实在客户端进行此时传递到服务器。三次握手，四次挥手：三次握手：数据传输指上图客户端到服务器的数据传输过程举例说明：四次挥手：总体的交互过程:持久化链接管线化：多次请求 无响应。早期请求与响应过程：安全1、 HTTP为什么是不安全的？问题不能这么问。 首先，HTTP协议本身不存在安全问题，且协议本身也几乎不会成为被攻击对象。所谓“HTTP不安全”指的是应用HTTP协议的服务器和客户端，以及运行在服务器上的web应用资源容易受到攻击，这些是不安全的。因为HTTP协议非常单纯，不具备会话管理，不具备加密处理。如果有需要，开发者需要自己设计（认证、会话管理），这种情况由于自行设计会出现多样性，这些多样性的设计就可能存在了安全问题使用的软件（WEB软件）存在漏洞2、 常见的WEB攻击HTTP与HTTPSHTTPS = HTTP+SSLhttps是http的一个安全通道，其安全保证是由ssl提供","categories":[{"name":"Net","slug":"Net","permalink":"https://upyounger.github.io/categories/Net/"}],"tags":[{"name":"Http","slug":"Http","permalink":"https://upyounger.github.io/tags/Http/"}]},{"title":"java发送邮件","slug":"java发送邮件","date":"2019-06-17T07:46:12.000Z","updated":"2019-08-02T04:46:05.530Z","comments":true,"path":"2019/06/17/java发送邮件/","link":"","permalink":"https://upyounger.github.io/2019/06/17/java发送邮件/","excerpt":"","text":"java 发送电子邮件（QQ邮箱为例）使用java mail发送邮件maven依赖：12345 &lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;javax.mail&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt;&lt;/dependency&gt;案例如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124/* * java 发送邮件 * */import javax.mail.Session;import javax.mail.Transport;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeMessage;import java.util.Date;import java.util.Properties;/** * JavaMail 版本: 1.6.0 * JDK 版本: JDK 1.7 以上（必须） */public class MailTools &#123; // 发件人的 邮箱 和 密码（替换为自己的邮箱和密码） // PS: 某些邮箱服务器为了增加邮箱本身密码的安全性，给 SMTP 客户端设置了独立密码（有的邮箱称为“授权码”）, // 对于开启了独立密码的邮箱, 这里的邮箱密码必需使用这个独立密码（授权码）。 public static String myEmailAccount = \"xxxxx@qq.com\"; // 授权码 public static String myEmailPassword = \"xxxxxx\"; // 发件人邮箱的 SMTP 服务器地址, 必须准确, 不同邮件服务器地址不同, 一般(只是一般, 绝非绝对)格式为: smtp.xxx.com // 网易163邮箱的 SMTP 服务器地址为: smtp.163.com // QQ邮箱的 SMTP 服务器地址为:smtp.qq.com public static String myEmailSMTPHost = \"smtp.qq.com\"; // 收件人邮箱（替换为自己知道的有效邮箱） public static String receiveMailAccount = \"xxxx@qq.com\"; public static void main(String[] args) throws Exception &#123; // 1. 创建参数配置, 用于连接邮件服务器的参数配置 Properties props = new Properties(); // 参数配置 props.setProperty(\"mail.transport.protocol\", \"smtp\"); // 使用的协议（JavaMail规范要求） props.setProperty(\"mail.smtp.host\", myEmailSMTPHost); // 发件人的邮箱的 SMTP 服务器地址 props.setProperty(\"mail.smtp.auth\", \"true\"); // 需要请求认证 // PS: 某些邮箱服务器要求 SMTP 连接需要使用 SSL 安全认证 (为了提高安全性, 邮箱支持SSL连接, 也可以自己开启), // 如果无法连接邮件服务器, 仔细查看控制台打印的 log, 如果有有类似 “连接失败, 要求 SSL 安全连接” 等错误, // 打开下面 /* ... */ 之间的注释代码, 开启 SSL 安全连接。 /* // SMTP 服务器的端口 (非 SSL 连接的端口一般默认为 25, 可以不添加, 如果开启了 SSL 连接, // 需要改为对应邮箱的 SMTP 服务器的端口, 具体可查看对应邮箱服务的帮助, // QQ邮箱的SMTP(SLL)端口为465或587, 其他邮箱自行去查看) final String smtpPort = \"465\"; props.setProperty(\"mail.smtp.port\", smtpPort); props.setProperty(\"mail.smtp.socketFactory.class\", \"javax.net.ssl.SSLSocketFactory\"); props.setProperty(\"mail.smtp.socketFactory.fallback\", \"false\"); props.setProperty(\"mail.smtp.socketFactory.port\", smtpPort); */ // 2. 根据配置创建会话对象, 用于和邮件服务器交互 Session session = Session.getInstance(props); session.setDebug(true); // 设置为debug模式, 可以查看详细的发送 log // 3. 创建一封邮件 MimeMessage message = createMimeMessage(session, myEmailAccount, receiveMailAccount); // 4. 根据 Session 获取邮件传输对象 Transport transport = session.getTransport(); // 5. 使用 邮箱账号 和 密码 连接邮件服务器, 这里认证的邮箱必须与 message 中的发件人邮箱一致, 否则报错 // // PS_01: 成败的判断关键在此一句, 如果连接服务器失败, 都会在控制台输出相应失败原因的 log, // 仔细查看失败原因, 有些邮箱服务器会返回错误码或查看错误类型的链接, 根据给出的错误 // 类型到对应邮件服务器的帮助网站上查看具体失败原因。 // // PS_02: 连接失败的原因通常为以下几点, 仔细检查代码: // (1) 邮箱没有开启 SMTP 服务; // (2) 邮箱密码错误, 例如某些邮箱开启了独立密码; // (3) 邮箱服务器要求必须要使用 SSL 安全连接; // (4) 请求过于频繁或其他原因, 被邮件服务器拒绝服务; // (5) 如果以上几点都确定无误, 到邮件服务器网站查找帮助。 // // PS_03: 仔细看log, 认真看log, 看懂log, 错误原因都在log已说明。 transport.connect(myEmailAccount, myEmailPassword); // 6. 发送邮件, 发到所有的收件地址, message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(message, message.getAllRecipients()); // 7. 关闭连接 transport.close(); &#125; /** * 创建一封只包含文本的简单邮件 * * @param session 和服务器交互的会话 * @param sendMail 发件人邮箱 * @param receiveMail 收件人邮箱 * @return * @throws Exception */ public static MimeMessage createMimeMessage(Session session, String sendMail, String receiveMail) throws Exception &#123; // 1. 创建一封邮件 MimeMessage message = new MimeMessage(session); // 2. From: 发件人（昵称有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改昵称） message.setFrom(new InternetAddress(sendMail, \"aaaaa\", \"UTF-8\")); // 3. To: 收件人（可以增加多个收件人、抄送、密送） message.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(receiveMail, \"examkuuserreceive\", \"UTF-8\")); // 4. Subject: 邮件主题（标题有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改标题） message.setSubject(\"aaaaa\", \"UTF-8\"); // 5. Content: 邮件正文（可以使用html标签）（内容有广告嫌疑，避免被邮件服务器误认为是滥发广告以至返回失败，请修改发送内容） Utils myUtils = new Utils(); message.setContent(\"aaaaaaaaaaaaa\", \"text/html;charset=UTF-8\"); // 6. 设置发件时间 message.setSentDate(new Date()); // 7. 保存设置 message.saveChanges(); return message; &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://upyounger.github.io/categories/Java/"}],"tags":[{"name":"java","slug":"java","permalink":"https://upyounger.github.io/tags/java/"}]},{"title":"Oracle 11g 配置允许远程连接","slug":"Oracle配置允许远程连接","date":"2019-05-31T00:32:18.000Z","updated":"2019-08-02T04:45:31.231Z","comments":true,"path":"2019/05/31/Oracle配置允许远程连接/","link":"","permalink":"https://upyounger.github.io/2019/05/31/Oracle配置允许远程连接/","excerpt":"","text":"Windows10 Oracle 11g设置允许远程连接（局域网）打开Net Manager（如果找不到这个应用，可以使用搜索功能在本地电脑上进行搜索）点击Oracle net配置—-》本地—-》监听程序—-》LISTENER,点击下方添加地址，输入ip地址和端口号。（Oracel默认端口号为1521，可根据需要自定义端口号，本例以1522端口为例子）点击文件—-》保存网络配置，退出开放1522端口，打开windows防火墙设置—-》高级设置—-》入站规则新建入站规则—-》端口，下一步—-》输入1522（自定义的端口），下一步—-》输入该入站规则的名称和描述，点击完成。注意事项：Oracle 服务要开启，至少开启OracleOraDb11g_home1TNSListener、OracleServiceORCL","categories":[{"name":"sql","slug":"sql","permalink":"https://upyounger.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://upyounger.github.io/tags/sql/"}]},{"title":"Oracle sql语句学习笔记","slug":"Oracle-sql语句学习笔记","date":"2019-05-23T08:18:36.000Z","updated":"2019-08-02T04:45:40.102Z","comments":true,"path":"2019/05/23/Oracle-sql语句学习笔记/","link":"","permalink":"https://upyounger.github.io/2019/05/23/Oracle-sql语句学习笔记/","excerpt":"","text":"Oracle sql语句学习笔记本笔记记录本人学习过程中常用到的知识1.分页查询oracle的分页查询有多重书写方式（深入学习oracle语句请参考官方文档），不同的书写方式效率也不同,下面是一种效率较高的写法。/ 这个表示注释/这个方法嵌套一层，速度快，当数据量大时，速度也很快。这种方法，在里层嵌套控制的查询的最大值，在最外层控制的最小值。12345678910111213SELECT * FROM ( SELECT ROWNUM AS rowno, t.* FROM SqlLearn /*(待查询的数据表）*/ t WHERE Edition BETWEEN &apos;2018&apos; AND &apos;2022&apos; AND ROWNUM &lt;= 15 /*（要查询的分页 本例从10到15）*/ ) SqlLearn_page WHERE SqlLearn_page.rowno &gt;= 10;也可以这样写：这时候在最外层控制最大值和最小值 ，相对来说第一种方法效率较高一点12345678910SELECT * FROM (SELECT a.*, ROWNUM rn FROM (SELECT * FROM SqlLearn WHERE Edition BETWEEN &apos;2018&apos; AND &apos;2022&apos;) a) WHERE rn BETWEEN 10 AND 152.日期处理TO_DATE格式(以时间:2019-05-23 17:45:25为例)1.日期和字符转换函数用法（to_date,to_char）1234567select to_char(sysdate,&apos;yyyy-mm-dd hh24:mi:ss&apos;) as nowTime from dual; //日期转化为字符串 select to_char(sysdate,&apos;yyyy&apos;) as nowYear from dual; //获取时间的年 select to_char(sysdate,&apos;mm&apos;) as nowMonth from dual; //获取时间的月 select to_char(sysdate,&apos;dd&apos;) as nowDay from dual; //获取时间的日 select to_char(sysdate,&apos;hh24&apos;) as nowHour from dual; //获取时间的时 select to_char(sysdate,&apos;mi&apos;) as nowMinute from dual; //获取时间的分 select to_char(sysdate,&apos;ss&apos;) as nowSecond from dual; //获取时间的秒2.字符串和时间互转12select to_date(&apos;2019-05-23 17:45:25&apos;,&apos;yyyy-mm-dd hh24:mi:ss&apos;) from dual //显示23-MAY-19select to_char( to_date(222,&apos;J&apos;),&apos;Jsp&apos;) from dual //显示Two Hundred Twenty-Two3.字符处理1.字符截取 substr（”字符”，a，b）只要 |a| ≤ b,取a的个数；当 |a| ≥ b时，才取b的个数，由a决定截取位置12345678select substr(&apos;HelloWorld&apos;,0,3) value from dual; //返回结果：Hel，截取从“H”开始3个字符select substr(&apos;HelloWorld&apos;,0,100) value from dual; //返回结果：HelloWorld，100虽然超出预处理的字符串最长度，但不会影响返回结果，系统按预处理字符串最大数量返回。select substr(&apos;HelloWorld&apos;,5,3) value from dual; //返回结果：oWoselect substr(&apos;Hello World&apos;,5,3) value from dual; //返回结果：o W (中间的空格也算一个字符串，结果是：o空格W)select substr(&apos;HelloWorld&apos;,-1,3) value from dual; //返回结果：d （从后面倒数第一位开始往后取1个字符，而不是3个。）select substr(&apos;HelloWorld&apos;,-2,3) value from dual; //返回结果：ld （从后面倒数第二位开始往后取2个字符，而不是3个 ）select substr(&apos;HelloWorld&apos;,-3,3) value from dual; //返回结果：rld （从后面倒数第三位开始往后取3个字符）select substr(&apos;HelloWorld&apos;,-4,3) value from dual; //返回结果：orl （从后面倒数第四位开始往后取3个字符）当只有两个参数时；不管是负几，都是从最后一个开始 往回截取1234567select substr(&apos;HelloWorld&apos;,0) value from dual; //返回结果：HelloWorld，截取所有字符select substr(&apos;HelloWorld&apos;,1) value from dual; //返回结果：HelloWorld，截取所有字符select substr(&apos;HelloWorld&apos;,2) value from dual; //返回结果：elloWorld，截取从“e”开始之后所有字符select substr(&apos;HelloWorld&apos;,3) value from dual; //返回结果：lloWorld，截取从“l”开始之后所有字符select substr(&apos;HelloWorld&apos;,-1) value from dual; //返回结果：d，从最后一个“d”开始 往回截取1个字符select substr(&apos;HelloWorld&apos;,-2) value from dual; //返回结果：ld，从最后一个“d”开始 往回截取2个字符select substr(&apos;HelloWorld&apos;,-3) value from dual; //返回结果：rld，从最后一个“d”开始 往回截取3个字符4.常用函数1.decode()decode(条件,值1,返回值1,值2,返回值2,…值n,返回值n,缺省值)该函数的含义如下：IF 条件=值1 THENRETURN(翻译值1)ELSIF 条件=值2 THENRETURN(翻译值2)……ELSIF 条件=值n THENRETURN(翻译值n)ELSERETURN(缺省值)END IF实例：select *from users;select id, username, age, decode(sex,0,’男’,1,’女’) from users;2.nvl() 为空值赋值函数声明：nvl(col,val)说明：当col为空时取val作为返回值，当col不为空时取col值。用处：最主要的是格式化数据，比如计算金额时，不想出现空数据，可以使用nvl(JINE,0)来得到0。由于null+(或-,*,/）数字等于null，所以在表达式中对可能为空的值要使用nvl由于null!=null，有时对可能为空的列进行条件查询时，可能出现结果集丢失数据问题，加上nvl就不会了。nvl2（）Oracle在NVL函数的功能上扩展，提供了NVL2函数。NVL2(E1, E2, E3)的功能为：如果E1为NULL，则函数返回E3，否则返回E2。E2和E3类型不同的话，E3会转换为E2的类型。限制：​ 1) E1可以是任意类型，E2,E3不能是long类型。​ 2) 如果 E2是字符类型，那么E3转为字符型再比较（null除外）。​ 3) 如果 E2是数值类型，那么E3也转为对应的数值类型。​ 4) 各个参数都不能是逻辑表达式nullif（）格式： nullif(expr1,expr2) 等价于 “case when expr1 = expr 2 then null else expr1 end”,相等返回NULL，不等返回expr1.限制： expr1不能是标识符null，录入nullif(null,expr2)那么会提示错误。expr1,expr2 都必须是一个变量或者是一个常量表达式，不能是逻辑表达式。lnnvl(a)a是一个表达式lnnvl只能用于where子句中；表达式的操作符号不能包含 AND, OR, BETWEEN。如果a的结果是false或者是unknown,那么lnnvl返回true;如果a的结果是true,返回false.“如果a的结果是false或者是unknown,那么lnnvl返回true”,这个很重要，因为一个空值或者unknown的值和另外一个常量或者有值的变量比较的时候，返回的总是unknown,所以lnnvl(a&gt;10) 等价于 nvl(a,0)&lt;=10 等价于 a&lt;=10 or a is null （假设a number(10))说白了，lnnvl是一种特定的用于简化表达式的函数，orcle解析的时候，应该会解析为 “a&lt;=10 or a is null”.3 case when1. CASE WHEN 表达式有两种形式12345678910111213--简单Case函数 CASE sex WHEN &apos;1&apos; THEN &apos;男&apos; WHEN &apos;2&apos; THEN &apos;女&apos; ELSE &apos;其他&apos; END --Case搜索函数 CASEWHEN sex = &apos;1&apos; THEN &apos;男&apos; WHEN sex = &apos;2&apos; THEN &apos;女&apos; ELSE &apos;其他&apos; END2. CASE WHEN 在语句中不同位置的用法2.1 SELECT CASE WHEN 用法1234567SELECT grade, COUNT (CASE WHEN sex = 1 THEN 1 /*sex 1为男生，2位女生*/ ELSE NULL END) 男生数, COUNT (CASE WHEN sex = 2 THEN 1 ELSE NULL END) 女生数 FROM students GROUP BY grade;2.3 WHERE CASE WHEN 用法12345678910SELECT T2.*, T1.* FROM T1, T2 WHERE (CASE WHEN T2.COMPARE_TYPE = &apos;A&apos; AND T1.SOME_TYPE LIKE &apos;NOTHING%&apos; THEN 1 WHEN T2.COMPARE_TYPE != &apos;A&apos; AND T1.SOME_TYPE NOT LIKE &apos;NOTHING%&apos; THEN 1 ELSE 0 END) = 12.4 GROUP BY CASE WHEN 用法1234567891011121314SELECT CASE WHEN salary &lt;= 500 THEN &apos;1&apos; WHEN salary &gt; 500 AND salary &lt;= 600 THEN &apos;2&apos; WHEN salary &gt; 600 AND salary &lt;= 800 THEN &apos;3&apos; WHEN salary &gt; 800 AND salary &lt;= 1000 THEN &apos;4&apos; ELSE NULL END salary_class, -- 别名命名COUNT(*) FROM Table_A GROUP BY CASE WHEN salary &lt;= 500 THEN &apos;1&apos; WHEN salary &gt; 500 AND salary &lt;= 600 THEN &apos;2&apos; WHEN salary &gt; 600 AND salary &lt;= 800 THEN &apos;3&apos; WHEN salary &gt; 800 AND salary &lt;= 1000 THEN &apos;4&apos; ELSE NULL END;3.1 在WHERE中特殊实现12345SELECT T2.*, T1.* FROM T1, T2 WHERE (T2.COMPARE_TYPE = &apos;A&apos; AND T1.SOME_TYPE LIKE &apos;NOTHING%&apos;) OR (T2.COMPARE_TYPE != &apos;A&apos; AND T1.SOME_TYPE NOT LIKE &apos;NOTHING%&apos;)这种方法也是在特殊情况下使用，要多注意逻辑，不要弄错。","categories":[{"name":"sql","slug":"sql","permalink":"https://upyounger.github.io/categories/sql/"}],"tags":[{"name":"sql","slug":"sql","permalink":"https://upyounger.github.io/tags/sql/"}]},{"title":"word指定位置设置页码","slug":"word指定位置设置页码","date":"2019-05-18T13:22:48.000Z","updated":"2019-08-02T04:44:56.486Z","comments":true,"path":"2019/05/18/word指定位置设置页码/","link":"","permalink":"https://upyounger.github.io/2019/05/18/word指定位置设置页码/","excerpt":"","text":"word 指定位置设置页码1.将光标移到指定页面的第一个字符所在的位置前2.选择布局，点击，在“分隔符”选项总中单击“下一页”3.在“插入中”选择“页码”，在出现的下拉选项中选择“页面底端”；待其下属选项出来了，再选择“普通数字2”。（自定也页码）4.将鼠标移动到灰色状态的“链接到前一节”，点击一下5.开始给指定的页面给Word设置页码：点击左上角的“页码”；然后再点击一下“设置页码格式”。在弹出的“页码格式”弹窗中，给页码编号选择“起始页码”，设置成想要的页码数，确定。","categories":[{"name":"Tools","slug":"Tools","permalink":"https://upyounger.github.io/categories/Tools/"}],"tags":[{"name":"word","slug":"word","permalink":"https://upyounger.github.io/tags/word/"}]},{"title":"软件工程各文档模板","slug":"软件工程各文档模板","date":"2019-05-18T01:17:21.000Z","updated":"2019-08-02T04:44:28.857Z","comments":true,"path":"2019/05/18/软件工程各文档模板/","link":"","permalink":"https://upyounger.github.io/2019/05/18/软件工程各文档模板/","excerpt":"","text":"​ 可行性报告引言1.1 编写目的1.2 项目背景1.3 定义研究前提2.1 功能要求2.2 性能要求2.3 限制条件现有系统分析3.1 处理流程3.2 工作负荷3.3 费用3.4 硬件环境3.5 人员配备3.6 存在的问题推荐的方案系统范围经济可行性技术可行性法律可行性可用性评价其他项目相关问题系统定义文档对待开发系统的一个全面、真实、简略的定义性说明文档。引言1.1 文档的范围和目的1.2 概述1.2.1 目标1.2.2 约束条件功能和数据描述2.1 系统体系结构(结构环境图ACD)2.2 ACD描述说明子系统描述3.1 子系统N的体系结构图定义3.1.1 体系结构流程图AFD3.1.2 系统模块描述3.1.3 性能问题描述3.1.4 设计约束3.1.5 系统构件分配3.2 体系结构字典3.3 结构互连图及其描述系统模型化和模拟结果4.1 用于模拟的系统模型4.2 模拟结果4.3 特殊的性能问题讨论项目问题5.1 项目开发成本5.2 项目进度安排附录需求规格说明书引言1.1 编写的目的1.2 项目背景1.3 定义1.4 参考资料任务概述2.1 目标2.2 运行环境2.3 条件与约束数据描述3.1 静态数据3.2 动态数据3.3 数据库描述3.4 数据字典3.5 数据采集功能需求4.1 功能划分4.2 功能描述性能需求5.1 数据精确度5.2 时间特性5.3 适应性运行需求6.1 用户界面6.2 硬件接口6.3 软件接口6.4 故障处理其他需求可使用性安全保密性可维护性可移植性概要设计说明书引言1.1 编写的目的1.2 项目背景1.3 定义1.4 参考资料任务概述2.1 目标2.2 运行环境2.3 需求概述2.4 条件与限制总体设计3.1 处理流程3.2 总体结构和模块外部设计（结构图）3.3 功能分配：表明各功能与程序的关系接口设计4.1 外部接口：用户界面、软件接口、硬件接口4.2 内部接口：模块之间的接口数据结构设计5.1 逻辑结构设计5.2 物理结构设计5.3 数据结构与程序的关系运行设计6.1 运行模块的组合6.2 运行控制6.3 运行时间出错处理设计7.1 出错输出信息7.2 出错处理对策安全保密设计维护设计用例文档用例编号用例名用例描述参与者前置条件后置条件基本路径1…….XXXX2 …….XXXX3 …….XXXX扩展点2a. XXXX2a1….XXXXX补充说明详细设计说明书引言1.1 编写目的：目的，阅读对象1.2 项目背景：项目来源，主管部门1.3 定义：术语定义，缩写词原意1.4 参考资料：资料版本，作者，来源…程序描述2.1 功能2.2 性能2.3 输出和输入项目2.4 算法2.5 程序逻辑：流程图，NS图，PDL，判定树，判定表…2.6 接口2.7 存储分配2.8 限制条件2.9 测试要点测试计划引言1.1 编写目的1.2 背景1.3 定义1.4 参考资料计划2.1 软件说明2.2 测试内容2.3 测试1(标识符)2.3.1 进度安排2.3.2 条件a. 设备b. 软件c. 人员2.3.3 测试资料a. 有关本项任务的文件b. 被测试程序及其所在的媒体c. 测试的输入和输出举例d. 有关控制此项测试的方法、过程的图表2.3.4 测试培训2.4 测试2(标识符)测试设计说明3.1 测试1(标识符)3.1 .1 控制3.1.2 输入3.1.3 输出3.2 测试2(标识符)评价准则4.1 范围4.2 数据整理4.3 尺寸测试分析报告：引言1.1 编写目的1.2 背景1.3 定义1.4 参考资料测试概要测试结果及发现3.1 测试1(标识符)3.2 测试2(标识符)对软件功能的结论4.1 功能1(标识符)4.1.1 能力4.1.2 限制4.2 功能2(标识符)分析摘要5.1 能力5.2 缺限和限制5.3 建议 a. 各项修改可采用的修改方法程度b. 各项修改的紧迫程度c. 各项修改预定的工作量d. 各项修改的负责人5.4 评价测试资源消耗","categories":[{"name":"文档","slug":"文档","permalink":"https://upyounger.github.io/categories/文档/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"https://upyounger.github.io/tags/软件工程/"}]},{"title":"Git常用命令","slug":"Git常用命令","date":"2019-05-14T11:01:20.000Z","updated":"2019-08-02T04:46:20.963Z","comments":true,"path":"2019/05/14/Git常用命令/","link":"","permalink":"https://upyounger.github.io/2019/05/14/Git常用命令/","excerpt":"","text":"Git常用命令总结git init​ 在本地新建一个repo,进入一个项目目录,执行git init,会初始化一个repo,并在当前文件夹下创建一个.git文件夹.git clone​ 获取一个url对应的远程Git repo, 创建一个local copy.​ 一般的格式是git clone [url].​ clone下来的repo会以url最后一个斜线后面的名称命名,创建一个文件夹,如果想要指定特定的名称,可以git clone [url] newname指定.git status​ 查询repo的状态.​ git status -s: -s表示short, -s的输出标记会有两列,第一列是对staging区域而言,第二列是对working目录而言.git log​ show commit history of a branch.​ git log –oneline –number: 每条log只显示一行,显示number条.​ git log –oneline –graph:可以图形化地表示出分支合并历史.​ git log branchname可以显示特定分支的log.​ git log –oneline branch1 ^branch2,可以查看在分支1,却不在分支2中的提交.^表示排除这个分支(Window下可能要给^branch2加上引号).​ git log –decorate会显示出tag信息.​ git log –author=[author name] 可以指定作者的提交历史.​ git log –since –before –until –after 根据提交时间筛选log.​ –no-merges可以将merge的commits排除在外.​ git log –grep 根据commit信息过滤log: git log –grep=keywords​ 默认情况下, git log –grep –author是OR的关系,即满足一条即被返回,如果你想让它们是AND的关系,可以加上–all-match的option.​ git log -S: filter by introduced diff.​ 比如: git log -SmethodName (注意S和后面的词之间没有等号分隔).​ git log -p: show patch introduced at each commit.​ 每一个提交都是一个快照(snapshot),Git会把每次提交的diff计算出来,作为一个patch显示给你看.​ 另一种方法是git show [SHA].​ git log –stat: show diffstat of changes introduced at each commit.​ 同样是用来看改动的相对信息的,–stat比-p的输出更简单一些.git add​ 在提交之前,Git有一个暂存区(staging area),可以放入新添加的文件或者加入新的改动. commit时提交的改动是上一次加入到staging area中的改动,而不是我们disk上的改动.​ git add .​ 会递归地添加当前工作目录中的所有文件.git diff​ 不加参数的git diff:​ show diff of unstaged changes.​ 此命令比较的是工作目录中当前文件和暂存区域快照之间的差异,也就是修改之后还没有暂存起来的变化内容.​ 若要看已经暂存起来的文件和上次提交时的快照之间的差异,可以用:​ git diff –cached 命令.​ show diff of staged changes.​ (Git 1.6.1 及更高版本还允许使用 git diff –staged，效果是相同的).​ git diff HEAD​ show diff of all staged or unstated changes.​ 也即比较woking directory和上次提交之间所有的改动.​ 如果想看自从某个版本之后都改动了什么,可以用:​ git diff [version tag]​ 跟log命令一样,diff也可以加上–stat参数来简化输出.​ git diff [branchA] [branchB]可以用来比较两个分支.​ 它实际上会返回一个由A到B的patch,不是我们想要的结果.​ 一般我们想要的结果是两个分支分开以后各自的改动都是什么,是由命令:​ git diff [branchA]…[branchB]给出的.​ 实际上它是:git diff $(git merge-base [branchA] [branchB]) [branchB]的结果.git commit​ 提交已经被add进来的改动.​ git commit -m “the commit message”​ git commit -a 会先把所有已经track的文件的改动add进来,然后提交(有点像svn的一次提交,不用先暂存). 对于没有track的文件,还是需要git add一下.​ git commit –amend 增补提交. 会使用与当前提交节点相同的父节点进行一次新的提交,旧的提交将会被取消.git reset​ undo changes and commits.​ 这里的HEAD关键字指的是当前分支最末梢最新的一个提交.也就是版本库中该分支上的最新版本.​ git reset HEAD: unstage files from index and reset pointer to HEAD​ 这个命令用来把不小心add进去的文件从staged状态取出来,可以单独针对某一个文件操作: git reset HEAD - - filename, 这个- - 也可以不加.​ git reset –soft​ move HEAD to specific commit reference, index and staging are untouched.​ git reset –hard​ unstage files AND undo any changes in the working directory since last commit.​ 使用git reset —hard HEAD进行reset,即上次提交之后,所有staged的改动和工作目录的改动都会消失,还原到上次提交的状态.​ 这里的HEAD可以被写成任何一次提交的SHA-1.​ 不带soft和hard参数的git reset,实际上带的是默认参数mixed.​ 总结:​ git reset –mixed id,是将git的HEAD变了(也就是提交记录变了),但文件并没有改变，(也就是working tree并没有改变). 取消了commit和add的内容.​ git reset –soft id. 实际上，是git reset –mixed id 后,又做了一次git add.即取消了commit的内容.​ git reset –hard id.是将git的HEAD变了,文件也变了.​ 按改动范围排序如下:​ soft (commit) &lt; mixed (commit + add) &lt; hard (commit + add + local working)git revert​ 反转撤销提交.只要把出错的提交(commit)的名字(reference)作为参数传给命令就可以了.​ git revert HEAD: 撤销最近的一个提交.​ git revert会创建一个反向的新提交,可以通过参数-n来告诉Git先不要提交.git rm​ git rm file: 从staging区移除文件,同时也移除出工作目录.​ git rm –cached: 从staging区移除文件,但留在工作目录中.​ git rm –cached从功能上等同于git reset HEAD,清除了缓存区,但不动工作目录树.git clean​ git clean是从工作目录中移除没有track的文件.​ 通常的参数是git clean -df:​ -d表示同时移除目录,-f表示force,因为在git的配置文件中, clean.requireForce=true,如果不加-f,clean将会拒绝执行.git mv​ git rm - - cached orig; mv orig new; git add newgit stash​ 把当前的改动压入一个栈.​ git stash将会把当前目录和index中的所有改动(但不包括未track的文件)压入一个栈,然后留给你一个clean的工作状态,即处于上一次最新提交处.​ git stash list会显示这个栈的list.​ git stash apply:取出stash中的上一个项目(stash@{0}),并且应用于当前的工作目录.​ 也可以指定别的项目,比如git stash apply stash@{1}.​ 如果你在应用stash中项目的同时想要删除它,可以用git stash pop​ 删除stash中的项目:​ git stash drop: 删除上一个,也可指定参数删除指定的一个项目.​ git stash clear: 删除所有项目.git branch​ git branch可以用来列出分支,创建分支和删除分支.​ git branch -v可以看见每一个分支的最后一次提交.​ git branch: 列出本地所有分支,当前分支会被星号标示出.​ git branch (branchname): 创建一个新的分支(当你用这种方式创建分支的时候,分支是基于你的上一次提交建立的).​ git branch -d (branchname): 删除一个分支.​ 删除remote的分支:​ git push (remote-name) :(branch-name): delete a remote branch.​ 这个是因为完整的命令形式是:​ git push remote-name local-branch:remote-branch​ 而这里local-branch的部分为空,就意味着删除了remote-branchgit checkoutgit checkout (branchname)切换到一个分支.​ git checkout -b (branchname): 创建并切换到新的分支.​ 这个命令是将git branch newbranch和git checkout newbranch合在一起的结果.​ checkout还有另一个作用:替换本地改动:​ git checkout –​ 此命令会使用HEAD中的最新内容替换掉你的工作目录中的文件.已添加到暂存区的改动以及新文件都不会受到影响.​ 注意:git checkout filename会删除该文件中所有没有暂存和提交的改动,这个操作是不可逆的.git merge​ 把一个分支merge进当前的分支.​ git merge [alias]/[branch]​ 把远程分支merge到当前分支.​ 如果出现冲突,需要手动修改,可以用git mergetool.​ 解决冲突的时候可以用到git diff,解决完之后用git add添加,即表示冲突已经被resolved.git tag​ tag a point in history as import.​ 会在一个提交上建立永久性的书签,通常是发布一个release版本或者ship了什么东西之后加tag.​ 比如: git tag v1.0​ git tag -a v1.0, -a参数会允许你添加一些信息,即make an annotated tag.​ 当你运行git tag -a命令的时候,Git会打开一个编辑器让你输入tag信息​ 我们可以利用commit SHA来给一个过去的提交打tag:​ git tag -a v0.9 XXXX​ push的时候是不包含tag的,如果想包含,可以在push时加上–tags参数.​ fetch的时候,branch HEAD可以reach的tags是自动被fetch下来的, tags that aren’t reachable from branch heads will be skipped.如果想确保所有的tags都被包含进来,需要加上–tags选项.git remote​ list, add and delete remote repository aliases.​ 因为不需要每次都用完整的url,所以Git为每一个remote repo的url都建立一个别名,然后用git remote来管理这个list.​ git remote: 列出remote aliases.​ 如果你clone一个project,Git会自动将原来的url添加进来,别名就叫做:origin.​ git remote -v:可以看见每一个别名对应的实际url.​ git remote add [alias] [url]: 添加一个新的remote repo.​ git remote rm [alias]: 删除一个存在的remote alias.​ git remote rename [old-alias] [new-alias]: 重命名.​ git remote set-url [alias] [url]:更新url. 可以加上—push和fetch参数,为同一个别名set不同的存取地址.git fetch​ download new branches and data from a remote repository.​ 可以git fetch [alias]取某一个远程repo,也可以git fetch –all取到全部repo​ fetch将会取到所有你本地没有的数据,所有取下来的分支可以被叫做remote branches,它们和本地分支一样(可以看diff,log等,也可以merge到其他分支),但是Git不允许你checkout到它们.git pull​ fetch from a remote repo and try to merge into the current branch.​ pull == fetch + merge FETCH_HEAD​ git pull会首先执行git fetch,然后执行git merge,把取来的分支的head merge到当前分支.这个merge操作会产生一个新的commit.​ 如果使用–rebase参数,它会执行git rebase来取代原来的git merge.git rebase​ –rebase不会产生合并的提交,它会将本地的所有提交临时保存为补丁(patch),放在”.git/rebase”目录中,然后将当前分支更新到最新的分支尖端,最后把保存的补丁应用到分支上.​ rebase的过程中,也许会出现冲突,Git会停止rebase并让你解决冲突,在解决完冲突之后,用git add去更新这些内容,然后无需执行commit,只需要:​ git rebase –continue就会继续打余下的补丁.​ git rebase –abort将会终止rebase,当前分支将会回到rebase之前的状态.git push​ push your new branches and data to a remote repository.​ git push [alias] [branch]​ 将会把当前分支merge到alias上的[branch]分支.如果分支已经存在,将会更新,如果不存在,将会添加这个分支.​ 如果有多个人向同一个remote repo push代码, Git会首先在你试图push的分支上运行git log,检查它的历史中是否能看到server上的branch现在的tip,如果本地历史中不能看到server的tip,说明本地的代码不是最新的,Git会拒绝你的push,让你先fetch,merge,之后再push,这样就保证了所有人的改动都会被考虑进来.git reflog​ git reflog是对reflog进行管理的命令,reflog是git用来记录引用变化的一种机制,比如记录分支的变化或者是HEAD引用的变化.​ 当git reflog不指定引用的时候,默认列出HEAD的reflog.​ HEAD@{0}代表HEAD当前的值,HEAD@{3}代表HEAD在3次变化之前的值.​ git会将变化记录到HEAD对应的reflog文件中,其路径为.git/logs/HEAD, 分支的reflog文件都放在.git/logs/refs目录下的子目录中.特殊符号:​ ^代表父提交,当一个提交有多个父提交时,可以通过在^后面跟上一个数字,表示第几个父提交: ^相当于^1.​ ~相当于连续的个^.","categories":[{"name":"Git Learn","slug":"Git-Learn","permalink":"https://upyounger.github.io/categories/Git-Learn/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://upyounger.github.io/tags/Git/"}]},{"title":"超爽踩点","slug":"超爽踩点","date":"2019-05-14T00:34:15.000Z","updated":"2019-08-02T04:43:17.939Z","comments":true,"path":"2019/05/14/超爽踩点/","link":"","permalink":"https://upyounger.github.io/2019/05/14/超爽踩点/","excerpt":"","text":"视频Demo：图片Demo：摘要图片大小为 801*309模板：12345678910111213$(document).ready(function() &#123; $(\"#xxx\").click(function()&#123; $.post(\"xxx//路径\", &#123;\"oid\":$(\"#xxx\").val(),\"uid\":$(\"#xxx\").val()&#125;, function(data)&#123; &#125;,\"text\"); &#125;); &#125;);&#125;","categories":[{"name":"Music","slug":"Music","permalink":"https://upyounger.github.io/categories/Music/"}],"tags":[{"name":"Music","slug":"Music","permalink":"https://upyounger.github.io/tags/Music/"},{"name":"vedio","slug":"vedio","permalink":"https://upyounger.github.io/tags/vedio/"}]}]}